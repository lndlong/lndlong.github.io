---
layout: post
title:  "Data Structures"
date:   2020-05-03 21:30:30 +0800
---

*前言
    起初我在看的是图书馆里拿的一本的《数据结构基础》，看的时候不单是出现代码上的印刷错误，而且我读起来很吃力，不知道它在讲什么，我觉得我太菜了。朋友推荐我去别的书，就像算法导论一样，说是导论，其实是最难的吧。   
    然后我取舍以后选择听清华的课，很难用cpp，这个是我不会的，渐渐学，学了以后发现我学的连C都不会用了。   
    用这个来记录一些笔记，然后还要写另一篇cpp相关的学习记录。   
                data:2020/05/03
 
 ---
 
 *二分查找
Fibonacci 查找
rand（）% = 0;

在查找插入元素到有序向量里面的时候，这个插入的元素应该是不大于插入元素的最后一个元素，这个
时候插入的这个元素所处的位置就是它自己的rank，而出现极端小与极端大的时候，这个时候就得在原
来的有序向量里添加两个哨兵向量，分别在头和尾，分别是无穷小和无穷大。

**二分查找
二分查找运用的是减而治之的思想，取选取有向向量的中间的那个值作为中间的那个部分，再从左边和右边
分别成为两外的两个大或者小的部分。

>while(lo< hi){
>	rank mi = (lo + hi) >> 1;	//这里是找到midle
>	if ( e < a[mi] ) hi =mi;	//到左区间查找
>	else if ( A[mi] < e) lo = mi +1;	//深入后半段查找，这里是将hi看作一个哨兵一样子，是在有用的向量里面不存在的界外的一个数，所以以这种思想的  >话，上一步就是将mi变成那个哨兵。
>	else return mi;	//如果既不是大于也不是小于则就是相等这种清苦，返回mi，为什么要都用小于呢，则是为了避免人为的识别错误
>}

**Fibonacci查找

Fibonacci数是黄金分割数，如果是按照二分查找法去查找数，每一次分割下来是将有序数列分半，则查找看似是一个三角形的很有美感的对称，但是偏向于后半部分的数列来说是需要额外   
多的查找次数的，因为里面的while循环结构体中的查找顺序，则如果用Fibonacci查找来分段邮箱序列则会避免这种查找出现的有偏颇的现象。这样子优化后时间复杂度O油原来的1.50log_2(n)   
变成1.44log_2(n)，因为原来是用0.5来划分而后面是用0.618这个比例来进行划分，而取Fibonacci数则运用其Fibonacci算法。

**二分查找（优化）

如果二分查找将分判变为两个，既去掉中间的正好等于查找数的判别的话就会造成只有不小于和大于两种情况，这样子相较于上面的二分查找这种二分查找始终会迭代将  有序向量查找完并找到最终需要查找的数，因为一直是均等的两次查找则不会出现如上面二分查找一样的不均等查找现象，则这样子的查找结果都是一个查找的过程数，  则会相较于前面的二分查找是会在靠后的有序查找的最坏情况下比较优秀的，但是承认最优化也是没有的。
>while(lo < hi){  //不变性: A[0,lo) <= e < A[hi,n)
>    rank mi=( lo + hi) >> 1；
>    （ e< A[mi]）? hi = mi ：lo = mi + 1; //[lo,mi)或（mi,hi）
>    } //出口时，A[lo=hi]为大于e的最小元素
>    return --lo; //故lo-1为不大于e的元素的最大秩

data: 2020/05/06_21:03
